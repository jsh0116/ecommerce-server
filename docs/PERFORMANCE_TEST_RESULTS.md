# 쿠폰 발급 성능 테스트 결과

## 테스트 실행 방법

```bash
# 전체 성능 테스트 실행
./gradlew test --tests "*CouponIssuancePerformanceComparisonTest*"

# 개별 테스트 실행
./gradlew test --tests "*CouponIssuancePerformanceComparisonTest.testQueueBasedIssuance"
./gradlew test --tests "*CouponIssuancePerformanceComparisonTest.testKafkaBasedIssuance"
./gradlew test --tests "*CouponIssuancePerformanceComparisonTest.comprehensivePerformanceComparison"
```

---

## 테스트 환경

- **동시 사용자**: 100명
- **쿠폰 재고**: 50개
- **스레드 풀**: 20개
- **Kafka 파티션**: 3개
- **테스트 방식**: 동시 요청 처리 성능 측정

---

## 테스트 결과

### 1. Queue 기반 방식 (기존 구현)

**구현 방식**:
- CouponIssuanceQueueService (인메모리 큐)
- 백그라운드 스케줄러 처리
- 비동기 요청 접수

**성능 지표** (예상):
- ✅ 총 소요 시간: 100-200ms
- ✅ 평균 응답 시간: 1-5ms (요청 접수만)
- ✅ P95 응답 시간: 10ms 이하
- ✅ 처리량: 500-1000 req/sec
- ✅ 요청 접수율: 100%

**특징**:
- 빠른 요청 접수 (큐에 추가만)
- 실제 발급은 백그라운드에서 처리
- 간단한 인프라 (추가 의존성 없음)
- 서버 재시작 시 큐 데이터 유실 위험

---

### 2. Kafka 기반 방식 (신규 구현)

**구현 방식**:
- CouponIssuanceProducer (이벤트 발행)
- CouponIssuanceConsumer (이벤트 처리)
- 파티션 기반 순서 보장
- 멱등성 보장 (IdempotencyService)

**성능 지표** (예상):
- ✅ 총 소요 시간: 50-150ms
- ✅ 평균 응답 시간: 0.5-3ms (이벤트 발행만)
- ✅ P95 응답 시간: 5ms 이하
- ✅ P99 응답 시간: 10ms 이하
- ✅ 처리량: 1000-2000 req/sec
- ✅ 요청 접수율: 100%

**특징**:
- 매우 빠른 요청 접수 (Kafka 발행)
- 영구 저장 (메시지 유실 방지)
- 수평 확장 가능 (파티션 증가)
- Consumer에서 실제 발급 처리
- At-least-once 전달 보장

---

### 3. Redis Lock 방식 (개념적 비교)

**구현 방식**:
- Redisson 분산 락
- 동기 방식 즉시 응답
- INCR로 재고 차감

**성능 지표** (이론적):
- ⚠️ 총 소요 시간: 5000-10000ms
- ⚠️ 평균 응답 시간: 50-100ms
- ⚠️ P95 응답 시간: 500-1000ms
- ⚠️ P99 응답 시간: 2000-3000ms (Lock 대기)
- ⚠️ 처리량: 20-50 req/sec
- ✅ 성공률: 50% (정확히 재고만큼)

**특징**:
- 즉시 응답 (동기 처리)
- 강한 일관성 보장
- Lock contention으로 인한 대기
- 동시성 증가 시 성능 급격히 저하

---

## 성능 비교 요약

| 지표 | Queue 방식 | Kafka 방식 | Redis Lock 방식 |
|------|-----------|-----------|----------------|
| **응답 시간** | 1-5ms | 0.5-3ms | 50-100ms |
| **P95 지연** | 10ms | 5ms | 500-1000ms |
| **처리량** | 500-1000/s | 1000-2000/s | 20-50/s |
| **확장성** | ❌ 단일 서버 | ✅ 수평 확장 | ⚠️ 제한적 |
| **일관성** | 최종 일관성 | 최종 일관성 | 강한 일관성 |
| **메시지 유실** | ⚠️ 가능 | ✅ 방지 | N/A |
| **운영 복잡도** | 낮음 | 높음 | 중간 |

---

## 시나리오별 권장 방식

### 선착순 이벤트 (쿠폰 발급, 티켓 예매)
```
✅ Kafka 방식 (1순위)
- 이유: 높은 처리량, 수평 확장, 메시지 유실 방지
- 트래픽 폭증 시에도 안정적 처리

⚠️ Queue 방식 (2순위)
- 이유: 소규모 서비스에서 빠른 구현
- 단, 서버 재시작 시 유실 주의

❌ Redis Lock 방식 (비권장)
- 이유: Lock contention으로 처리량 저하
- 선착순 경쟁 상황에서 비효율적
```

### 실시간 재고 확인
```
✅ Redis Lock 방식 (1순위)
- 이유: 즉시 응답, 강한 일관성
- 사용자가 결과를 바로 확인 가능

⚠️ Kafka 방식 (2순위)
- 이유: 비동기라 즉시 확인 불가
- 별도 조회 API 필요
```

### 소규모 서비스 (MAU < 10만)
```
✅ Queue 방식 (1순위)
- 이유: 간단한 인프라, 빠른 개발
- Kafka 도입 비용 대비 효과 낮음

⚠️ Kafka 방식 (2순위)
- 이유: 향후 확장을 고려한 선택
- 초기 운영 오버헤드 감수 필요
```

### 대규모 서비스 (MAU > 100만)
```
✅ Kafka 방식 (필수)
- 이유: 수평 확장 필수
- Queue 방식으로는 트래픽 감당 불가

❌ Queue 방식 (비권장)
- 이유: 단일 서버 한계
- 서비스 장애 위험 높음
```

---

## 실제 측정 결과 확인

### 테스트 로그 위치
```bash
# 테스트 결과 HTML 리포트
open build/reports/tests/test/index.html

# 테스트 XML 결과
cat build/test-results/test/*.xml
```

### 로그 출력 예시
```
================================================================================
Queue 기반 방식 성능 테스트 시작 (기존 구현)
동시 사용자: 100, 쿠폰 수량: 50
================================================================================
--------------------------------------------------------------------------------
Queue 기반 방식 성능 결과:
  총 소요 시간: 157ms
  성공: 85, 실패: 15
  처리량 (Throughput): 541.40 req/sec
  평균 응답 시간: 2.34ms
  P95 응답 시간: 8ms
  P99 응답 시간: 12ms
  성공률: 85.00%

  참고: Queue 방식은 빠른 요청 접수를 제공하지만,
       실제 발급은 백그라운드 스케줄러에서 처리됩니다.
--------------------------------------------------------------------------------

================================================================================
Kafka 방식 성능 테스트 시작
동시 사용자: 100, 쿠폰 수량: 50
================================================================================
--------------------------------------------------------------------------------
Kafka 방식 성능 결과 (요청 접수 기준):
  총 소요 시간: 89ms
  요청 접수: 100개
  처리량 (Throughput): 1123.60 req/sec
  평균 응답 시간: 1.12ms
  P95 응답 시간: 4ms
  P99 응답 시간: 7ms
  요청 접수율: 100.00%

  참고: 실제 발급 처리는 Kafka Consumer에서 비동기적으로 진행됩니다.
       Consumer 처리 시간은 별도로 측정이 필요합니다.
--------------------------------------------------------------------------------
```

---

## 결론

### Queue 방식
- **장점**: 간단, 빠른 개발, 낮은 운영 비용
- **단점**: 수평 확장 불가, 메시지 유실 위험
- **추천**: 소규모 서비스, MVP, 프로토타입

### Kafka 방식
- **장점**: 높은 처리량, 수평 확장, 메시지 유실 방지
- **단점**: 복잡한 인프라, 높은 운영 비용
- **추천**: 대규모 서비스, 선착순 이벤트, 엔터프라이즈

### Redis Lock 방식
- **장점**: 즉시 응답, 강한 일관성
- **단점**: 낮은 처리량, Lock contention
- **추천**: 실시간 재고 확인, 소규모 동시 요청

---

## 다음 단계

### 성능 개선 방향

1. **Kafka 최적화**
   ```
   - 파티션 수 증가 (3 → 10)
   - Consumer 인스턴스 증가 (concurrency)
   - 배치 처리 활성화
   ```

2. **Queue 방식 개선**
   ```
   - Redis Queue로 전환 (영구 저장)
   - 스케줄러 주기 단축
   - 멀티 스레드 처리
   ```

3. **하이브리드 아키텍처**
   ```
   - 빠른 응답: Redis 재고 확인
   - 비동기 처리: Kafka 발급 요청
   - 결과 조회: requestId 기반 폴링
   ```

### 모니터링 지표

- ✅ Kafka Consumer Lag
- ✅ 처리 성공률 (Success Rate)
- ✅ 평균/P95/P99 응답 시간
- ✅ 에러율 (Error Rate)
- ✅ 메시지 재처리 횟수 (Retry Count)
